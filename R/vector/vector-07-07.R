# example(persp)
x <- c(1,6,2,6,9)
mode(x)
typeof(x)

x <- c(x[1:2], 10, 48, x[3:5]) # x 只是对向量的引用，向量的在创建时就固定了
length(x) # 获取向量的长度
1:5 # A:B 返回从A开始，以整数1为间隔的所有小于等于B的数
1:-5 == c(1, 0, -1, -2, -3, -4, -5)
1.2:5.7 == c(1.2, 2.2, 3.2, 4.2, 5.2)
3:6+4 == c(7,8,9,10) # : 的优先级高于普通运算符

# 对向量进行运算时，如果两个向量长度不一致，R会自动对短的一个进行循环补齐
# 矩阵实际是一种特殊的向量，增加了行和列维度，但R在处理时是将矩阵当做一个长向量进行处理，默认按列连接
y <- c(0,1,3) + c(1,2,3,4,5) # 实际运行为 c(0,1,3,0,1) + c(1,2,3,4,5)
m1 <- matrix(c(1,2,3,4,5,6), nrow = 3, ncol = 2)
# 矩阵与向量进行运算时，是将矩阵还原成向量，进行向量运算，在将结果转化为原有维度的矩阵
m1 + c(0, 1) # 实际为 c(1,2,3,4,5,6)+c(0,1,0,1,0,1)
# m1 + c(1,1,1,1,1,1,1,1,1,1,1,1,1) 抛出异常，向量长度不能超过矩阵长度

2+3 == 5
"+"(2,3) == 5 # R中每个运算符就是一个函数，R调用函数的方式也可以函数名的字符串，在加上括号
"length"(c(0,4,5))
# R中的运算符 + - * / %% == > < 都只能对一元向量进行运算
# 当向量使用这些运算符时，实际是每个元素都进行一次相应的运算，并且会进行循环补齐
c(1,2,3) * c(0,2,1) == c(0,4,3)
c(1,2,3) / c(0,2) == c(Inf, 1 , Inf)
c(7,8,5) %% c(3,2,4) == c(1,0,1)
(c(0,1) == c(0,2,3)) == c(TRUE, FALSE, FALSE)
(c(0,1) == c(0,2,3)) == c(TRUE, FALSE, FALSE)
(c(2,6,9,3) > 5) == c(FALSE,TRUE,TRUE,FALSE) 
(c(6,5,9,3) >= 5) == c(TRUE,TRUE,TRUE,FALSE) 

# 向量的索引取值使用[]，放入[]中的实际上还是向量，R会找出所有下标与[]中向量的元素相同的项，组成新的向量
v1 <- c(2,4,5,67,2,65,78)
v1[c(9,4)] == c(NA, 67) # 下标越界时返回NA
v1[4:6] == c(67,2,65)
v1[3] == c(5)
v1[c(-2,-3)] == c(2, 67, 2, 65, 78) # 负数表示排除，取之外的元素
excludeLast <- function(v){
  return(v[-length(v)])
}
excludeLast(excludeLast(v1)) == c(2,4,5,67,2) 

# seq()函数
# 1. 可以类似于 : 创建向量序列，并且可以设置元素的间距
seq(from=2.1, to=9.9, by=0.5) # by参数设置元素的间距
# 默认 from=1，to=1，by=1
seq() == 1
# 根据参数数量有不同的实现
seq(5) == c(1,2,3,4,5) 
# 2. 当参数是一个长度大于1的向量时，取该向量的下标作为结果
seq(c(3,7,9,1)) == c(1,2,3,4)
# rep()生成重复序列函数
# 将指定向量重复指定次数，拼接成新的向量，同时能指定每次复制时每个元素的重复次数
rep(c(1,3), times=3) == c(1, 3, 1, 3, 1, 3)
rep(0, times=4) == c(0,0,0,0)
rep(c(3,6), 3, each=2) == c(3, 3, 6, 6, 3, 3, 6, 6, 3, 3, 6, 6) # each 指定每次复制时每个元素的重复次数
rep(4) # 默认只输出一次

# all() any() 用于判断向量中TRUE的个数
any(c(4,1,7,3) < 3) == TRUE # 是否向量中包含TRUE
any(c(4,1,7,3) < 1) == FALSE 
all(c(4,1,7,3) < 5) == FALSE # 是否全部为TRUE
all(c(4,1,7,3) < 8) == TRUE

