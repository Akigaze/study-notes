数据结构
===
1. 一维
    * 向量：数值型变量，元素的数据类型一样
    * 因子：分类变量
2. 二维
    * 矩阵
    * 数据框
3. 多维
    * 数组
    * 列表

![R语言的数据类型](pic\R语言-数据结构.png)

---

# 声明变量
直接使用变量名定义，无需再前面指明变量类型

## 赋值
1. 等号操作符：=
2. 箭头操作符：<-

在声明的变量外加上括号，可以在执行声明语句的同时，打印该变量的内容，如：
(a <- c(1,1,1,))

## 搜索路径
相当于全局变量  
在搜索路径中的变量，可以直接访问它的属性或域  
一个对象可以同时多次添加到搜索路径中

### 查看搜索路径
1. search(): 返回搜索路径中的所有变量

## 查看对象的数据结构
1. class(): 当作用在向量上时，结果与`mode()`是一样的。

## 查看对象的数据类型
1. mode()

## 统计变量的行数和列数
* `nrow(x)`
* `ncol(x)`
---

# 向量
## 创建向量
1. c()：combine
2. 冒号操作符: ：a:b 表示从a到b步长为1的所有元素组成的向量
3. seq(from,to,by,length,along.with)：from 起点，to 终点，by 步长 ，length为向量的长度，along.with指定一个向量，是具有相同的长度

## 提取向量子集
1. 元素下标：正数，表示想要的元素；负数，表示不要的元素；支持向量；下标从1开始
2. which()：根据传入的关于向量的表达式，返回元素的下标，如：which(y > 5)

------------

# 因子
因子是一种特殊的向量
* 水平：向量元素的分类
* 标签：每个水平对应的字符
* 值：在R语言中每个标签都会对应一个数值，默认按字母顺序按1,2,3排列

对于一个因子变量，打印出来的结果包括两部分：
1. 向量对应的标签序列
2. 水平：`levels:...`

## unclass()
查看一个因子各个标签对应的数值
返回结果包括三部分：
1. 向量的数值序列
2. `attr(,"levels")`
3. 向量对应的标签序列

## 创建因子
1. factor(): 将一个向量转化为因子；参数：
    * x：参数向量
    * levels：也是一个向量，指定水平以及各标签的顺序，从而决定各个标签对应的数值

2. gl()：根据水平生成因子；参数：
    * n：水平的个数
    * k：每个水平重复的次数
    * labels：向量形式，每个水平对应的标签

-------------

# 矩阵
所有数据类型必须一样  
向量相当于一种特殊的矩阵，行维度或列维度为 1 的矩阵  
也可以将矩阵理解为一种特殊的向量，行维度和列维度都大于 1 的向量

## 创建矩阵
1. matrix(): 给定数据向量，指定行数和列数
    * data: 填充矩阵的数据，为一个向量
    * nrow: 行数
    * ncol: 列数
    * byrow: 按行填充，T(ture)，默认为按列填充,F(false)
2. dim(): 修改向量的维度，dim(x) <- value
    * x: 要修改维度的数据对象
    * value: 数字向量，元素的个数表示维度，每个元素的值表示对应维度元素的个数；默认第一个维度是列方向，第二个维度为行方向
    * **example**: `x <- 1:12 ; dim(x) <- c(3,4)`
3. cbind()&rbind(): 将向量组合成矩阵，`cbind()`为案列组合，`rbind()`为按行组合
    * ...: 任意数量的向量，用于组合

## 获取矩阵元素
1. 下标访问：从1开始；支持向量表示下标，表示同一维度下的多个下标
    * [m,n]: 取第m行第n列的元素
    * [m,]: 取第m行的所有元素
    * [,n]: 取第n列的所有元素
2. 名称访问：若行和列有设置名称的，可以用名称代替下标访问元素，其中指定名称时用 **字符串**

## 行列命名
1. colnames()&rownames():用向量指定行维度或列维度的的名字，`colnames(x) <- value`
    * x: 需要命名的矩阵对象
    * value: 向量表示，每个元素表示一行或者一列的名字

## 矩阵运算
1. 转置：
    * t(): t(x)，x为需要转置的矩阵对象
2. 加减：
    * 数字加减：+
    * 矩阵加减：+
3. 乘法：
    * 数乘：*
    * 矩阵对应元素相乘：*
    * 矩阵的乘法：%\*%
4. 逆矩阵：
    * solve(): 将待求解的矩阵作为参数传入；若传入两个矩阵，会变成求方程组

## 生成对角矩阵
1. diag(): 传入参数的数据类型不同，作用也有所不同
    * 数字：生成指定大小的单位对角矩阵
    * 向量：指定对角矩阵的对角元素
    * 矩阵：提取矩阵的对角元素，生成向量

# 数据框
相当于一种特殊的矩阵，不同列的数据类型可以不同
* 域：每一列称为一个域，每个列中的数据类型必须一致
* 记录：每一行称为一个记录，一个记录中的数据可以有不同类型

## 创建数据库
1. data.frame():
    * ...: 以`tag = value`的形式，表示一个域的名称`tag`和所有数据`value`

## 获取元素
1. 下标访问：与矩阵一样的方式
2. $符号：以`dataFrame$domain`的形式，指定域的名称，返回域的所有数据组成的向量
3. [[]]符号：以`dataFrame[[index]]`的形式，功能与 **$** 相同，返回指定下标的列的数据，同时，也可以用域的名称字符串代替下标
4. 搜索路径：将数据框对象到搜索路径中，再直接用域名访问数据
    1. attach(): 将对象加入到搜索路径
    2. detach(): 将对象从搜索路径中移除

## 数据框操作
1. 增加/修改域：
    1. within():
        * data: 要修改的数据框对象
        * expr：操作表达式，使用`{name = value}`的形式可以修改指定`name`的域或新增一个域
    2. $符号新增一个域，并赋值
    3. edit(): 弹出表格进行可视化修改数据框，但是并不会修改原有的表格，而是返回一个新的表格
    4. fix(): 与`edit`类似，会修改原来的数据框

2. 取子集：
    1. subset():
        * x: 数据框对象
        * subset: 对记录进行过滤的逻辑表达式，可以不写数据对象(默认为参数`x`的对象)
        * select: 对域进行过滤，使用向量的形式指定需要的域

# 列表
列表中可以包含向量，矩阵，数据框，列表等各种类型的数据  
成分：列表中的一个数据对象称为一个成分

## 创建列表
1. list(): 与创建数据框相似，都是`tag = value`的形式，`tag`为成分的名称

## 成分名称
1. names(): 查看或修改列表的成分名称，为`names(x) <- value`形式，没有value的情况下，直接返回列表所有成分的名称
    * x: 列表对象
    * value: 新的成分名称的向量

## 获取元素
1. []符号：指定成分的名称，返回的结果是由目标成分组成的一个新的列表
2. [[]]符号：指定成分的名称，直接返回目标成分的数据对象
3. $符号：与[[]]功能相同

----------------

# 数组
多维的数据结构，相当于三维或以上的矩阵  
元素数据必须一致
## 创建数组：
1. array(): 指定数据集合和维度信息
    * data：填充数组的数据集，通常是向量
    * dim：维度信息，向量的形式

## 访问元素
与矩阵相似

# 数据类型转换
## 类型转换
即不同类型(字符，数字，布尔)的数据之间的转换，存在一个安全级别的问题  
安全级别：字符 > 数字 > 布尔  
创建向量或者矩阵时，若提供了类型不同的数据，R会对数据进行隐式自动转换  
### 判断数据类型
* is：`is.数据类型()`的形式，判断作为参数的数据对象是否为指定的数据类型；数据类型包括了`character`，`number`等

### 数据类型转换
* as：`as.数据类型()`的形式，将参数的对象转换为指定数据类型

## 结构转换
不同数据结构(矩阵，数组，列表等)之间的转换，也存在`is`和`as`两种对结构进行判断和转换的方式

# 分支结构
## if...else...
不支持向量化操作  
```
if(bool condition){
    ...
}else{
    ...
}
```
## ifelse()
`ifelse(test, yes, no)`
支持向量化操作
* test：判断条件，支持向量化
* yes：test为TRUE的返回值
* no：test为FALSE的返回值

# 循环结构
## for
```
for(n in x){
    ...
}
```

## while
```
while(condition){
    ...
}
```

## repeat
死循环结构，没有循环条件
```
repeat{
    ...
}
```
## break-next
* break
* next：相当于 `continue`
