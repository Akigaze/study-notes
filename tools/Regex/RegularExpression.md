# Regular Expression(正则表达式)
## 通配符`.`
`.` 在正则表达式中可以匹配任意一个字符，**换行符除外**。

![](..\pic\regex\regex-1.png)

`\.` 使用 `\` 对 `.` 进行转义，只匹配文本中的符号 `.`。

![](..\pic\regex\regex-2.png)

## 符号匹配符`\w`与`\W`(word)
`\w` 可以匹配任意一个 **数字**，**大小写字母** 或 **下划线** 符号。

![](..\pic\regex\regex-3.png)

`\W` 相当于 `\w` 的补集，匹配 **数字**，**大小写字母**，**下划线** 以及 **换行符** 以外的任意一个字符。

![](..\pic\regex\regex-4.png)

## 数字匹配符`\d`与`\D`(digit)
`\d` 匹配任意一个 **数字**。

![](..\pic\regex\regex-5.png)

`\D` 相当于 `\d` 的补集，匹配 **数字** 和 **换行符** 以外的任意一个字符。

![](..\pic\regex\regex-6.png)

## 空白匹配符`\s`与`\S`(space)
`\s` 匹配任意一个空白符号，包括 **空格**，**制表符** 和 **换行符**。

![](..\pic\regex\regex-7.png)

`\S` 相当于 `\s` 的补集，匹配任意一个非空白的符号，即 **空格**，**制表符** 和 **换行符** 以外的任意一个字符。

![](..\pic\regex\regex-8.png)

## 匹配字的边界`\b`与`\B`
`\b` 用于匹配 **字** 的边界，所谓的字是指 **大小写字母**，**数字** 和 **下划线**。一个 **字的边界** 就是一个字不被另外一个"字"字符跟随的位置或者没有其他"字"字符在其前面的位置，即 `\b` 之前或之后被匹配中的内容的前或后不能再是一个 **字**。一个匹配的字的边界并 **不包含** 在匹配的内容中，也就是说 `\b` 匹配返回的内容长度是0。

![](..\pic\regex\regex-28.png)

`\B` 并不完全是 `\b` 的补集，`\B` 会根据之前或之后被匹配中的内容，判断结果两端的符号，若是 **字**，则下一个位置的符号也必须是字；若是 **非字** 符号的，下一个字符也必须是非字。一般用 `\B` 会产生一些奇怪的结果。

![](..\pic\regex\regex-29.png)

### Unicode码匹配符
在正则表达式中 `\u` 表示Unicode字符的前缀，随后跟 **四位16进制** 的 **数字**，表示一个Unicode码，`\u` 只有在后面的 **十六进制数** 在 `0000-ffff`的范围才有特殊意义，并且必须是 **四位数字**，否则 `\u` 就仅仅只是 `u` 的转义字符，实际上就还是 `u`。

汉字的Unicode码范围大概在 `\u4e00` 到 `\u9fa5` 之间。

Unicode码匹配汉字：

![](..\pic\regex\regex-9.png)

无效的Unicode码：

![](..\pic\regex\regex-10.png)


## 字符范围`[]`
`[]` 可以限定一个正在字符的 **匹配范围**，所有写在 `[]` 中的字符都是 **或** 的关系，所以一个 `[]` 只代表 **一个正则字符** 。如：
> 123abc_+=  
**>** [abc]  
**>** 结果：a, b, c

在 `[]` 中，`-` 符号有特殊的含义，`a-z` 表示从a到z的所有字符，`-` 表示一个 **连续的字符** 范围，所以只能用于 **字母** 之间或 **数字** 之间，并且必须是 **从小指向大** 的。若要匹配文本中的 `-` 则需要使用转义符 `\-`

`[]` 中 `-` 使用的情形：
1. 大写字母的范围：A-Z，C-O
2. 小写字母的范围：a-z，f-w
3. 大写字母到小写字母的范围：A-z，X-h
4. 数字范围：0-9，3-6

![](..\pic\regex\regex-11.png)

`Z-a` 的Unicode码范围是 `\u005A` 到 `\u0061` 中间还包含了6个符号，分别是 `[`，`\`，`]`，`^`，`_` 和 **```** ，所以一般不用 `A-z` 的写法，而是用 `A-Za-z` 来匹配所有字母。

## 多次匹配`+`
`+` 可以匹配它 **前面的** 一个正则字符 **一次或多次**，所以 `+` 不能使用在正则表达式的开头：

![](..\pic\regex\regex-12.png)

## 匹配零次或以上`*`
`*` 与 `+` 类似，可以匹配它 **前面的** 一个正则字符，但是它可以匹配 **0次或一次或多次**，所以 `*` 可以匹配不到任何字符，用于匹配那些可有可无的符号。 `*` 也不能使用在正则表达式的开头：

![](..\pic\regex\regex-13.png)

## 匹配零次或一次`？`
`？` 与 `*` 和 `+` 类似，可以匹配它 **前面的** 一个正则字符，但是它只能匹配 **0次或一次**，所以 `？` 也可以匹配不到任何字符，用于匹配那些可有可无，但是又只会出现一次的符号。 `？` 也不能使用在正则表达式的开头：

![](..\pic\regex\regex-14.png)

## 重复次数`{}`
`{}` 可以指定它前面的一个正则字符 **重复出现的次数**，基本用法是 `{a,b}`:
1. `{a}`：指定重复a次，{2}，{10}
2. `{a,b}`：指定最少重复a次，最多重复b次，{2,10}，{5,6}
3. `{a,}`：指定最少重复a次，没有重复的次数上限要求，{1,}，{0,}

`{}` 只有上述 **三种用法**，没有 `{,b}` 的用法。

![](..\pic\regex\regex-15.png)

`?`，`*`，`+` 都是 `{}` 的几种特殊情况，是 `{}` 的便捷用法：
- `?` = `{0,1}`
- `*` = `{0,}`
- `+` = `{1,}`

## 分组`()`
在正则表达式中，使用 `()` 可以对表达式进行分组，以便在处理文本时可以单独使用每个分组匹配出来的信息。进行分组的表达式匹配的结果一般会 **存储** 起来(消耗内存)，并且分配序号，分组的 **序号** 一般是从1开始，顺序按 **左括号** 出现的顺序分配。

![](..\pic\regex\regex-16.png)

### 分组重复次数
在分组之后使用限定次数的 `?`，`*`，`+` 或 `{}` 会将整个分组看做整体进行重复的匹配，若有 **连续重复** 的被匹配中，则该分组保存在内存中的结果为 **最后一个** 匹配到的值。

![](..\pic\regex\regex-26.png)

### 指代分组结果`\n`
这里的 `n` 是指分组的序号，在一次正则匹配中，可以使用 `\n` 的形式获取当次匹配指定分组所匹配到的值。序号必须在指定的分组出现之后才能使用。

![](..\pic\regex\regex-30.png)

### 分组嵌套
分组中可以嵌套分组，此时分组的序号依然按 **左括号** 出现的顺序，所以内部的 `()` 编号比外部的大。

![](..\pic\regex\regex-31.png)

## 或匹配`|`
`|` 会 **切割** 正则表达式，将表达式分成两份，两个子表达式分别会去文本中做匹配，起到一个 **或** 的功能。在一个正则表达式中也可以使用对个 `|` ，表示有更多的情况。

![](..\pic\regex\regex-17.png)

当 `|` 用在 `()` 分组中时，只对分组中的表达式进行切割。

![](..\pic\regex\regex-18.png)

## 分组不捕获`(?:)`
在 `()` 分组中，使用 `?:` 作为前缀，可以不为该分组分配序号，即 **不保存** 分组的匹配结果。

![](..\pic\regex\regex-19.png)

## 正向预查`(?=)`与`(?!)`
正向预查包括 **正向肯定预查** 和 **正向否定预查**，匹配的内容必须在 **最后面** ，并且 **不会返回** 匹配到的结果。

### 正向肯定预查`(?=)`
在 `(?=)` 的等号后加入正则表达式，表示需要匹配到的内容，到时这部分内容并不会被加入到匹配的结果中去，一般用法是 `a(?=b)`，可用于匹配某些字符 **之前** 的内容。

没有 `(?=b)c`的用法。

![](..\pic\regex\regex-20.png)

### 正向否定预查`(?!)`
与正向肯定预查相似，但要求不匹配指定的正则表达式，所以否定预查也可以不匹配中任何字符。

`a(?!b)` 形式的正向否定预查，在b匹配时，会往前匹配，直到碰到一个不匹配的，再将它从整个正则表达式的匹配结果中排除掉，所以可能造成多了一些不符合的结果，所以需要将a也加入否定的范围，即 `a(?!b|a)` 的用法。

![](..\pic\regex\regex-21.png)

## 反向预查`(?<=)`与`(?<!)`
反预查包括 **反向肯定预查** 和 **反向否定预查**，匹配的内容必须在 **最前面** ，并且 **不会返回** 匹配到的结果。

### 反向肯定预查`(?<=)`
在 `(?<=)` 的等号后加入正则表达式，表示需要匹配到的内容，到时这部分内容并不会被加入到匹配的结果中去，一般用法是 `(?<=a)b`，可用于匹配某些字符 **之后** 的内容。

没有 `a(?<=b)`的用法。

![](..\pic\regex\regex-22.png)

### 反向否定预查`(?<!)`
与反向肯定预查相似，但要求不匹配指定的正则表达式，所以否定预查也可以不匹配中任何字符。

`(?<!a)b` 形式的反向否定预查，在a匹配时，会往后匹配，直到碰到一个不匹配的，再将它从整个正则表达式的匹配结果中排除掉，所以可能造成多了一些不符合的结果，所以需要将b也加入否定的范围，即 `(?!a|b)b` 的用法。

![](..\pic\regex\regex-23.png)

### 对正向预查和反向预查的理解
对于正向预查 `\d+(?=元)`，`\d+(?!刀|\d)` 或反向预查 `(?<=￥)\d+`，`(?<!\$|\d)\d+`，在进行匹配时，应该是先对预查以外的 `\d+` 进行匹配，再从匹配结果的正向(后)或者反向(前)进行预查的正则表达式的匹配。

对于肯定预查，若匹配中，则停止匹配返回结果；若没匹配中，则进入 `\d+` 匹配中的内容中继续进行匹配，知道匹配中或者没有内容可以匹配为止。

对于否定预查则相反，匹配中会继续匹配，不中才结束匹配。

## 匹配输入开始`^`
对于一行或多行文本的匹配，可以使用 `^` 匹配 **输入的开始** 位置，但并 **不返回** 任何内容。默认情况下对一个文本，只匹配整个文本开始的位置。当 **多行(multiple)标志** 被设置为 `true` 时，那么也匹配 **换行符** 后紧跟的位置，即匹配每一行的其实位置。所以通常情况下，`^` 用于正则表达式的开头，用在后面一般不生效。

![](..\pic\regex\regex-24.png)

## 匹配范围的补集`[^]`
`[^a]` 的形式，表示在取a的补集。

`^` 只有在 `[]` 的第一个字符的位置才有取补集的功能，在其他位置就仅仅表示 `^` 这个符号。

![](..\pic\regex\regex-25.png)

`[^]` 表示匹配任何字符，包括空格，换行，制表符等

## 匹配输入结尾`$`
`$` 类似于 `^`，但它是匹配 **输入的结尾** 位置，也 **不返回** 任何内容。默认情况只匹配整个文本结尾的位置。当 **多行(multiple)标志** 被设置为 `true` 时，那么也匹配多行的结尾。

![](..\pic\regex\regex-27.png)

---
# Link
### 表严肃讲正则表达式 表/28.x
https://biaoyansu.com/28.x    
### MDN 正则表达式  
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions
### 廖雪峰 正则表达式
https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000
### 正则工具
https://regexr.com/  
### Graphemica Unicode码查询
https://graphemica.com/
